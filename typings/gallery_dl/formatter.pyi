"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable
from typing import Any

from gallery_dl_bytes.downloader import KWDict

"""String formatters"""

NONE = ...

def parse(
    format_string: str, default: Any = ..., fmt: Callable[[object, str], str] = ...
) -> (
    ExpressionFormatter
    | FStringFormatter
    | ModuleFormatter
    | StringFormatter
    | TemplateFStringFormatter
    | TemplateFormatter
): ...

class StringFormatter:
    """Custom, extended version of string.Formatter

    This string formatter implementation is a mostly performance-optimized
    variant of the original string.Formatter class. Unnecessary features have
    been removed (positional arguments, unused argument check) and new
    formatting options have been added.

    Extra Conversions:
    - "l": calls str.lower on the target value
    - "u": calls str.upper
    - "c": calls str.capitalize
    - "C": calls string.capwords
    - "g": calls text.slugify()
    - "j": calls json.dumps
    - "t": calls str.strip
    - "T": calls util.datetime_to_timestamp_string()
    - "d": calls text.parse_timestamp
    - "s": calls str()
    - "S": calls util.to_string()
    - "U": calls urllib.parse.unescape
    - "r": calls repr()
    - "a": calls ascii()
    - Example: {f!l} -> "example"; {f!u} -> "EXAMPLE"

    # Go to _CONVERSIONS and _SPECIFIERS below to se all of them, read:
    # https://github.com/mikf/gallery-dl/blob/master/docs/formatting.md

    Extra Format Specifiers:
    - "?<before>/<after>/":
        Adds <before> and <after> to the actual value if it evaluates to True.
        Otherwise the whole replacement field becomes an empty string.
        Example: {f:?-+/+-/} -> "-+Example+-" (if "f" contains "Example")
                             -> ""            (if "f" is None, 0, "")

    - "L<maxlen>/<replacement>/":
        Replaces the output with <replacement> if its length (in characters)
        exceeds <maxlen>. Otherwise everything is left as is.
        Example: {f:L5/too long/} -> "foo"      (if "f" is "foo")
                                  -> "too long" (if "f" is "foobar")

    - "J<separator>/":
        Joins elements of a list (or string) using <separator>
        Example: {f:J - /} -> "a - b - c" (if "f" is ["a", "b", "c"])

    - "R<old>/<new>/":
        Replaces all occurrences of <old> with <new>
        Example: {f:R /_/} -> "f_o_o_b_a_r" (if "f" is "f o o b a r")
    """
    def __init__(self, format_string, default=..., fmt=...) -> None: ...
    def format_map(self, kwdict: KWDict) -> str:
        """Apply 'kwdict' to the initial format_string and return its result"""
        ...

class ExpressionFormatter:
    """Generate text by evaluating a Python expression"""
    def __init__(self, expression, default=..., fmt=...) -> None: ...

class ModuleFormatter:
    """Generate text by calling an external function"""
    def __init__(self, function_spec, default=..., fmt=...) -> None: ...

class FStringFormatter:
    """Generate text by evaluating an f-string literal"""
    def __init__(self, fstring, default=..., fmt=...) -> None: ...

class TemplateFormatter(StringFormatter):
    """Read format_string from file"""
    def __init__(self, path, default=..., fmt=...) -> None: ...

class TemplateFStringFormatter(FStringFormatter):
    """Read f-string from file"""
    def __init__(self, path, default=..., fmt=...) -> None: ...

def parse_field_name(
    field_name,
):  # -> tuple[Literal['_lit'], tuple[itemgetter[Any]]] | tuple[Any, list[Any]]:
    ...

class Literal:
    @staticmethod
    def __getitem__(key): ...

_literal = ...
_CACHE = ...
_SEPARATOR = ...
_GLOBALS = ...
_CONVERSIONS = ...
_FORMAT_SPECIFIERS = ...
